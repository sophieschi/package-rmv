#!/usr/bin/env python
from json import dumps
import pytz
import re
import sys
import time
import traceback
from requests import get
from datetime import datetime, timedelta
from calendar import timegm
from hosted import CONFIG, NODE, DEVICE

CONFIG.restart_on_update()

request_minutes = 30

def log(msg):
    print >>sys.stderr, "[rmv] %s" % msg

def current_time():
    timezone = pytz.timezone("Europe/Berlin")
    now = datetime.utcnow()
    now = now.replace(tzinfo=pytz.utc)
    now = now.astimezone(timezone)
    now = now.replace(tzinfo=None)
    return now

def to_unixtimestamp(dt):
    return timegm(dt.timetuple())

def regenerate():
    global request_minutes

    now = current_time()

    def parse(stop_info):
        departures = {}
        remove = re.escape(CONFIG['remove'].strip())

        stop_name = None

        for departure in stop_info['Departure']:
            try:
                stop = re.sub('^('+remove+'[- ])', '', departure['stop'].encode('utf-8'))
                direction = re.sub('^('+remove+'[- ])', '', departure['direction'].encode('utf-8'))
                track = departure.get('track', '').strip()
                scheduled = datetime.strptime(departure['date'] + ' ' + departure['time'], '%Y-%m-%d %H:%M:%S')

                if not stop_name:
                    stop_name = stop.decode('utf-8')

                leave_time = None
                delay = 0
                line_no = ''
                category = -1
                operator_code = None
                for product in departure['Product']:
                    if product.get('line') and product.get('catCode'):
                        line_no = product['line']
                        category = product['catCode']
                        operator_code = product.get('operatorCode', None)
                        break

                if 'rtTime' in departure and 'rtDate' in departure:
                    real_time = datetime.strptime(departure['rtDate'] + ' ' + departure['rtTime'], '%Y-%m-%d %H:%M:%S')
                    leave_time = real_time
                    diff = real_time - scheduled
                    delay = int(diff.total_seconds()/60)

                departures['{} {} {}'.format(leave_time or scheduled, line_no, direction)] = {
                    'direction': direction.decode('utf-8'),
                    'line_no': str(line_no),
                    'category': category,
                    'track': track,
                    'scheduled': scheduled.strftime('%H:%M'),
                    'actual': leave_time.strftime('%H:%M') if leave_time else '',
                    'timestamp': to_unixtimestamp(leave_time or scheduled),
                }
            except Exception as e:
                traceback.print_exc()
                #log(repr(e))

        return departures, stop_name

    def download(stop, minutes, key):
        if key.startswith('http://') or key.startswith('https://'):
            key = key.rstrip('/')
            url = "{prefix}/{stop}.json".format(
                prefix=key,
                stop=stop,
            )
        else:
            url = "https://www.rmv.de/hapi/departureBoard?id={stop}&duration={minutes}&format=json&accessId={key}".format(
                stop=stop,
                minutes=minutes,
                key=key,
            )
        log("Requesting {stop} info from {url}".format(
            stop=stop,
            url=url,
        ))
        r = get(url)
        r.raise_for_status()
        #r.encoding = 'utf-8'
        return r.json()

    def calculate_request_minutes(departures_per_minute, request_minutes):
        calculated_departure_height = departures_per_minute * request_minutes * 70

        while calculated_departure_height <= screen_height:
            request_minutes += 30
            calculated_departure_height = departures_per_minute * request_minutes * 70

            if request_minutes >= 1440:
                # Don't ever show more than one day of departures
                break

        return request_minutes

    departures = []
    min_deps_per_request = 1000

    for stop_id in CONFIG['stop'].split(','):
        deps, stop_name = parse(download(stop_id, request_minutes, CONFIG['key']))

        sorted_deps = []

        for _, departure in sorted(deps.items()):
            sorted_deps.append(departure)

        departures.append({
            'id': stop_id,
            'name': stop_name,
            'departures': sorted_deps,
        })

        min_deps_per_request = min(min_deps_per_request, len(sorted_deps))

    # pprint(departures, width=300)

    # Now that we know the departure list, we can calculate if we actually
    # have enough departures to fill the whole screen. If not, we calculate
    # how many minutes we'd need, so we can request more on the next run
    if not (CONFIG["key"].startswith('http://') or CONFIG["key"].startswith('https://')):
        log('current request_minutes is {}'.format(request_minutes))

        screen_height = DEVICE.screen_resolution[1]
        departures_per_minute = min_deps_per_request/float(request_minutes)
        departures_height = len(departures)*(CONFIG["font_size"]+20)

        log('there are {} departures per minute, filling {} pixels currently (want {})'.format(departures_per_minute, departures_height, screen_height))

        if departures_height < screen_height:
            # This assumes we get an equal amount of departures per minute
            # over the hour. It's okay to assume that, because if our calculation
            # turns out wrong, we'll just increase the amount of minutes next
            # time again.
            request_minutes = calculate_request_minutes(departures_per_minute, request_minutes)

        elif departures_height > screen_height*2:
            # Something weird happened, we got way more departures than expected.
            # Let's re-calculate the amount of departures we need, because we
            # don't want to request lots of data that will never be shown.
            # The inner if is needed to avoid calculating the minutes over and
            # over, if a 30 minute request gets us more than double our screen
            # height of data.
            if request_minutes > 30:
                request_minutes = calculate_request_minutes(departures_per_minute, 30)

        log('new request_minutes is {}'.format(request_minutes))

    log('writing {} stations to json'.format(len(departures)))
    with file("departures.json", "wb") as f:
        f.write(
            dumps(
                departures,
                ensure_ascii=False,
            ).encode("utf8")
        )

def send_clock():
    NODE['/clock/set'](to_unixtimestamp(current_time()))

def idle(seconds):
    end = time.time() + seconds
    while time.time() < end:
        send_clock()
        time.sleep(5)

def main():
    while 1:
        try:
            regenerate()

            if CONFIG["key"].startswith('http://') or CONFIG["key"].startswith('https://'):
                idle(15)
            else:
                request_limit = 4900

                if CONFIG['requests_max'] <= request_limit:
                    request_limit = CONFIG['requests_max']

                number_of_stops = len(CONFIG['stop'].split(','))
                sleep_time = 86400 / ( request_limit / number_of_stops)

                if sleep_time < 30:
                    sleep_time = 30

                idle(sleep_time)
        except Exception:
            traceback.print_exc()
            time.sleep(30)

if __name__ == "__main__":
    main()
